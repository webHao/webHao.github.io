<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://yoursite.com">
  <title>孙昊男的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="擅长各项前端技能">
<meta property="og:type" content="website">
<meta property="og:title" content="孙昊男的个人博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="孙昊男的个人博客">
<meta property="og:description" content="擅长各项前端技能">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="孙昊男的个人博客">
<meta name="twitter:description" content="擅长各项前端技能">
  
    <link rel="alternative" href="/atom.xml" title="孙昊男的个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/assets/blogImg/favicon.ico">
  
  <link rel="stylesheet" href="/main.css">
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="/assets/blogImg/mine.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Sun Hao Nan</a></h1>
		</hgroup>

		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/photos">相册</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/webhao" title="github">github</a>
		        
					<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
		        
					<a class="mail" target="_blank" href="/13001038373@163.com" title="mail">mail</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">Sun Hao Nan</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="/assets/blogImg/mine.jpg" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">Sun Hao Nan</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/photos">相册</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/webhao" title="github">github</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
						<a class="mail" target="_blank" href="/13001038373@163.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        
  
    <article id="post-OOP-02" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/07/OOP-02/">面向对象编程 OOP (02)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="面向对象-02"><a href="#面向对象-02" class="headerlink" title="面向对象-02"></a>面向对象-02</h1><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="1-扩展原型对象实现继承"><a href="#1-扩展原型对象实现继承" class="headerlink" title="1.扩展原型对象实现继承"></a>1.扩展原型对象实现继承</h3><h3 id="2-替换原型对象实现继承"><a href="#2-替换原型对象实现继承" class="headerlink" title="2.替换原型对象实现继承"></a>2.替换原型对象实现继承</h3><h3 id="3-混入继承"><a href="#3-混入继承" class="headerlink" title="3.混入继承"></a>3.混入继承</h3><h3 id="4-原型-混入继承"><a href="#4-原型-混入继承" class="headerlink" title="4.原型+混入继承"></a>4.原型+混入继承</h3><h3 id="5-经典继承"><a href="#5-经典继承" class="headerlink" title="5.经典继承"></a>5.经典继承</h3><h3 id="6-借用构造函数实现继承"><a href="#6-借用构造函数实现继承" class="headerlink" title="6.借用构造函数实现继承"></a>6.借用构造函数实现继承</h3>
      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/11/07/OOP-02/" class="archive-article-date">
  	<time datetime="2016-11-07T01:44:18.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-11-07</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-OOP-01" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/06/OOP-01/">面向对象编程 OOP (01)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="面向对象-01"><a href="#面向对象-01" class="headerlink" title="面向对象-01"></a>面向对象-01</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h2><p><strong>面向对象</strong> : 面向对象是一种编程思想,这种思想帮助我们解决问题的时候，将问题的主体放在对象上面，需要先分析对象是什么，对象做了什么事情.</p>
<p><strong>对象</strong> :</p>
<ul>
<li>键值对的集合</li>
<li>封装了属性（特征）和方法（行为）</li>
</ul>
<h2 id="2-创建对象"><a href="#2-创建对象" class="headerlink" title="2.创建对象"></a>2.创建对象</h2><h3 id="2-1通过对象字面量创建对象"><a href="#2-1通过对象字面量创建对象" class="headerlink" title="2.1通过对象字面量创建对象"></a>2.1通过对象字面量创建对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var obj = &#123;name:&apos;小明&apos;&#125;</div></pre></td></tr></table></figure>
<h3 id="2-2属性的设置"><a href="#2-2属性的设置" class="headerlink" title="2.2属性的设置"></a>2.2属性的设置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">obj.age = 23</div><div class="line">obj[&quot;say&quot;]=function()&#123;&#125;</div></pre></td></tr></table></figure>
<h3 id="2-3属性和方法的读取"><a href="#2-3属性和方法的读取" class="headerlink" title="2.3属性和方法的读取"></a>2.3属性和方法的读取</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">obj.age</div><div class="line">obj.say()</div></pre></td></tr></table></figure>
<h3 id="2-4属性和方法的删除"><a href="#2-4属性和方法的删除" class="headerlink" title="2.4属性和方法的删除"></a>2.4属性和方法的删除</h3><p><code>delete obj.say;</code> //只能删除自身所在的内存中的属性和方法</p>
<h2 id="3-构造函数"><a href="#3-构造函数" class="headerlink" title="3.构造函数"></a>3.构造函数</h2><p>有一些对象他们有共同的特征和行为,就用构造函数来创建对象</p>
<p><strong>好处</strong> : 一次封装,多次调用,节省代码,让代码更具可读性</p>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function Person(nam,age)&#123;</div><div class="line">this.name = name;</div><div class="line">this.age = age;</div><div class="line">this.walk = function()&#123;&#125;</div><div class="line">&#125;</div><div class="line">var p1 = new Person();</div></pre></td></tr></table></figure>
<h2 id="4-原型"><a href="#4-原型" class="headerlink" title="4.原型"></a>4.原型</h2><p><strong>代码示例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function Person()&#123;&#125; //构造函数</div><div class="line">var p1 = new Person(); //原型对象</div><div class="line">Person.prototype.constructor === Person</div><div class="line">p1.__proto__ == Person.prototype</div></pre></td></tr></table></figure>
<p><strong>完整原型链</strong></p>
<img src="/2016/11/06/OOP-01/prototype.png" alt="prototype.png" title="">
<h3 id="4-1-对象的属性读取"><a href="#4-1-对象的属性读取" class="headerlink" title="4.1 对象的属性读取"></a>4.1 对象的属性读取</h3><ol>
<li>查找当前对象的内存中是否定义了该属性,找到该属性就停止查找.</li>
<li>第一步没有找到,就去当前对象的<strong>proto</strong>属性(原型对象)查找,找到该属性则停止查找.</li>
<li>第二步没找到,就去原型对象的原型对象中查找</li>
<li>找到某个对象(是没有原型对象的,也就是<strong>proto</strong>==null)如果还找不到则确定无法获取该属性.</li>
</ol>
<h3 id="4-2-设置对象的"><a href="#4-2-设置对象的" class="headerlink" title="4.2 设置对象的"></a>4.2 设置对象的</h3><p><code>jackson.sing = function(){}</code></p>
<h3 id="4-3-删除对象属性"><a href="#4-3-删除对象属性" class="headerlink" title="4.3 删除对象属性"></a>4.3 删除对象属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">delete jackson.sing; //如果jackson本身不存在sing属性,不会报错</div><div class="line">delete jackson.__proto__.sing;//删除原型对象中的sing属性</div></pre></td></tr></table></figure>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/11/06/OOP-01/" class="archive-article-date">
  	<time datetime="2016-11-06T11:44:42.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-11-06</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-issue-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/05/issue-1/">IP地址访问页面错误问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="WebStormIP地址访问页面错误问题"><a href="#WebStormIP地址访问页面错误问题" class="headerlink" title="WebStormIP地址访问页面错误问题"></a>WebStormIP地址访问页面错误问题</h1><p>手机端访问WebStorm做出的页面，遇到了根据IP地址访问页面错误的问题</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><img src="/2016/11/05/issue-1/issue_1.png" alt="issue_1.png" title="">

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/11/05/issue-1/" class="archive-article-date">
  	<time datetime="2016-11-05T10:11:04.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-11-05</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-canvas" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/04/canvas/">canvas</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-基本篇"><a href="#1-基本篇" class="headerlink" title="1. 基本篇"></a>1. 基本篇</h1><h2 id="1-1-什么是Canvas"><a href="#1-1-什么是Canvas" class="headerlink" title="1.1 什么是Canvas"></a>1.1 什么是Canvas</h2><p> canvas 是 HTML5 提供的一个用于展示绘图效果的标签.<br>canvas 原意画布, 帆布. 在 HTML 页面中用于展示绘图效果.<br>最早 canvas 是苹果提出的一个方案, 今天已经在大多数浏览器中实现.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">canvas 英 [&apos;kænvəs]  美 [&apos;kænvəs]   帆布 画布</div></pre></td></tr></table></figure>
<h2 id="1-1-1-Canvas的基本用法"><a href="#1-1-1-Canvas的基本用法" class="headerlink" title="1.1.1 Canvas的基本用法"></a>1.1.1 Canvas的基本用法</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;canvas&gt;&lt;/canvas&gt;</div></pre></td></tr></table></figure>
<ol>
<li>使用 canvas 标签, 即可在页面中开辟一格区域. 可以设置其 width 和 height 设置该区域的尺寸.</li>
<li>默认 canvas 的宽高为 300 和 150.</li>
<li>不要使用 CSS 的方式设置宽高, 应该使用 HTML 属性.</li>
<li>如果浏览器不支持 canvas 标签, 那么就会将其解释为 div 标签. 因此常常在 canvas 中嵌入文本, 以提示用户浏览器的能力.</li>
<li>canvas 的兼容性非常强, 只要支持该标签的, 基本功能都一样, 因此不用考虑兼容性问题.</li>
<li>canvas 本身不能绘图. 是使用 JavaScript 来完成绘图. canvas 对象提供了各种绘图用的 api.</li>
</ol>
<h2 id="1-2-基本绘图"><a href="#1-2-基本绘图" class="headerlink" title="1.2 基本绘图"></a>1.2 基本绘图</h2><h3 id="1-2-1-基本绘图方法"><a href="#1-2-1-基本绘图方法" class="headerlink" title="1.2.1 基本绘图方法"></a>1.2.1 基本绘图方法</h3><p><strong>绘图步骤</strong></p>
<ol>
<li>获得 canvas 对象.</li>
<li>调用 getContext 方法, 提供字符串参数 ‘2d’.</li>
<li>该方法返回 CanvasRenderingContext2D 类型的对象. 该对象提供基本的绘图命令.</li>
<li>使用 CanvasRenderingContext2D 对象提供的方法进行绘图.</li>
<li>基本绘图命令</li>
</ol>
<ul>
<li>设置开始绘图的位置: <code>context.moveTo( x, y ).</code></li>
<li>设置直线到的位置: <code>context.lineTo( x, y ).</code></li>
<li>描边绘制:<code>context.stroke().</code></li>
<li>填充绘制:<code>context.fill().</code></li>
<li>闭合路径:<code>context.closePath().</code></li>
</ul>
<h4 id="1-2-1-1-绘制直线"><a href="#1-2-1-1-绘制直线" class="headerlink" title="1.2.1.1 绘制直线"></a>1.2.1.1 绘制直线</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var canvas = document.createElement( &apos;canvas&apos; );</div><div class="line">    canvas.width = 500;</div><div class="line">    canvas.height = 400;</div><div class="line">    canvas.style.border = &apos;1px dashed red&apos;;</div><div class="line">    document.body.appendChild( canvas );</div><div class="line">    // 获得 CanvasRenderingContext2D 对象</div><div class="line">    var context = canvas.getContext( &apos;2d&apos; );</div><div class="line">    // 设置 起点</div><div class="line">    context.moveTo( 0, 0 );</div><div class="line">    // 绘制直线</div><div class="line">    context.lineTo( 500, 400 );</div><div class="line">    // 设置 起点</div><div class="line">    context.moveTo( 0, 400 );</div><div class="line">    // 绘制直线</div><div class="line">    context.lineTo( 500, 0 );</div><div class="line">    // 描边显示效果</div><div class="line">    context.stroke();</div></pre></td></tr></table></figure>
<p>运行结果为:</p>
<img src="/2016/11/04/canvas/line-1.png" alt="line-1.png" title="">
<h4 id="1-2-1-2-getContext-方法"><a href="#1-2-1-2-getContext-方法" class="headerlink" title="1.2.1.2 getContext 方法"></a>1.2.1.2 getContext 方法</h4><p>语法: <code>Canvas.getContext( typeStr )</code></p>
<p>描述:</p>
<ol>
<li>该方法用于绘制上下文工具.</li>
<li>如果是绘制平面图形使用 ‘2d’ 作为参数, 如果绘制立体图形使用 ‘webgl’.</li>
<li>使用 ‘2d’ 返回 CanvasRenderingContext2D 类型的对象.</li>
<li>使用 ‘webgl’ 返回 WebGLRenderingContext 类型的对象.</li>
</ol>
<h4 id="1-2-1-3-moveTo-方法"><a href="#1-2-1-3-moveTo-方法" class="headerlink" title="1.2.1.3 moveTo 方法"></a>1.2.1.3 moveTo 方法</h4><p>语法: <code>CanvasRenderingContext2D.moveTo( x, y )</code></p>
<p>描述:</p>
<ol>
<li>该方法用于设置绘制起点.</li>
<li>其中参数 x, y 表示在坐标系中的位置, 分别是 x 坐标与 y 坐标.</li>
</ol>
<h4 id="1-2-1-4-lineTo-方法"><a href="#1-2-1-4-lineTo-方法" class="headerlink" title="1.2.1.4 lineTo 方法"></a>1.2.1.4 lineTo 方法</h4><p>语法: <code>CanvasRenderingContext2D.lineTo( x, y )</code></p>
<p>描述:</p>
<ol>
<li>该方法用于设置需要绘制直线的另一个点. 最终描边后会连线当前点和方法参数描述的点.</li>
<li>其中参数 x, y 表示在坐标系中的位置, 分别是 x 坐标与 y 坐标.</li>
</ol>
<h4 id="1-2-1-5-小结"><a href="#1-2-1-5-小结" class="headerlink" title="1.2.1.5 小结"></a>1.2.1.5 小结</h4><ol>
<li>绘图先要获得上下文, 即绘图工具</li>
<li>绘图需要设置开始的坐标</li>
<li>绘图是先描点, 然后一个一个依次连线</li>
<li>依次绘图只能绘制单一样式( 色彩等 )</li>
</ol>
<h3 id="1-2-2-直线图形"><a href="#1-2-2-直线图形" class="headerlink" title="1.2.2 直线图形"></a>1.2.2 直线图形</h3><ol>
<li>绘制直线计算坐标.</li>
<li>描边调用 <code>CanvasRenderingContext2D.stroke()</code> 方法.</li>
<li>填充使用 <code>CanvasRenderingContext2D.fill()</code> 方法.</li>
</ol>
<h4 id="1-2-2-1-fill-方法"><a href="#1-2-2-1-fill-方法" class="headerlink" title="1.2.2.1 fill 方法"></a>1.2.2.1 fill 方法</h4><p>语法: <code>CanvasRenderingContext2D.fill()</code></p>
<p>描述: 该方法会按照描绘的点的路径来填充图形. 默认是黑色.</p>
<h3 id="1-2-3-非零环绕原则"><a href="#1-2-3-非零环绕原则" class="headerlink" title="1.2.3 非零环绕原则"></a>1.2.3 非零环绕原则</h3><p>填充满足非零环绕原则</p>

<p>说明:</p>
<p>在 <code>canvas</code> 中使用各种方法描点实际上描述的是一个称为路径( path )的东西.<br>在 <code>canvas</code> 绘图中, 所有描述的东西都是路径, 只有最后填充或描边的时候才会显示出效果.<br>每一个路径都是一个状态.</p>
<h3 id="1-2-4-闭合路径"><a href="#1-2-4-闭合路径" class="headerlink" title="1.2.4 闭合路径"></a>1.2.4 闭合路径</h3><p><strong>closePath 方法</strong></p>
<p>语法: <code>CanvasRenderingContext2D.closePath()</code></p>
<p>描述: 使用该方法可以将最后一个描点与最开始的描点自动连接起来.</p>
<p><strong>小demo:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">...</div><div class="line"> ctx.moveTo( 100, 100 );</div><div class="line"> ctx.lineTo( 300, 100 );</div><div class="line"> ctx.lineTo( 300, 200 );</div><div class="line"> ctx.closePath();</div><div class="line"> ctx.stroke();</div></pre></td></tr></table></figure></p>
<p>图示:</p>
<img src="/2016/11/04/canvas/pic-1.png" alt="pic-1.png" title="">
<h3 id="1-2-5-路径的概念"><a href="#1-2-5-路径的概念" class="headerlink" title="1.2.5 路径的概念"></a>1.2.5 路径的概念</h3><ol>
<li>路径就是一次绘图</li>
</ol>
<ul>
<li>类比使用油漆刷墙面</li>
<li>首先打底色, 绝对不会一次性使用多个色彩</li>
<li>一定是先画完某一个色彩再考虑另一个色彩</li>
<li>除非需要自己创作才会考虑墙面绘画</li>
<li>路径就好比一桶油漆和一把刷子, 一次性描点绘制. 如果重新更换油漆, 那么是绘制另一个区域.</li>
<li>如果需要开启新的绘制, 那么使用 <code>CanvasRenderingContext2D.beginPath()</code> 方法.</li>
</ul>
<h3 id="1-2-6-线型相关属性"><a href="#1-2-6-线型相关属性" class="headerlink" title="1.2.6 线型相关属性"></a>1.2.6 线型相关属性</h3><p>设置描边与填充不一定只能使用黑色的细线. 可以利用一些属性设置其效果</p>
<ol>
<li><code>CanvasRenderingContext2D.lineWidth 设置线宽.</code></li>
<li><code>CanvasRenderingContext2D.lineCap 设置线末端类型.</code></li>
<li><code>CanvasRenderingContext2D.lineJoin 设置相交线的拐点.</code></li>
<li><code>CanvasRenderingContext2D.getLineDash() 获得线段样式数组.</code></li>
<li><code>CanvasRenderingContext2D.setLineDash() 设置线段样式.</code></li>
<li><code>CanvasRenderingContext2D.lineDashOffset 绘制线段偏移量.</code></li>
</ol>
<h4 id="1-2-6-1-设置线宽"><a href="#1-2-6-1-设置线宽" class="headerlink" title="1.2.6.1 设置线宽"></a>1.2.6.1 设置线宽</h4><p>语法: <code>CanvasRenderingContext2D.lineWidth = number</code></p>
<p><strong>小demo</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">...</div><div class="line">ctx.moveTo( 100, 100 );</div><div class="line">ctx.lineTo( 300, 100 );</div><div class="line">ctx.stroke();</div><div class="line"></div><div class="line">ctx.beginPath();</div><div class="line">ctx.lineWidth = 10;</div><div class="line">ctx.moveTo( 100, 250 );</div><div class="line">ctx.lineTo( 300, 250 );</div><div class="line">ctx.stroke();</div></pre></td></tr></table></figure>
<img src="/2016/11/04/canvas/pic-2.png" alt="pic-2.png" title="">
<h4 id="1-2-6-2-设置末端类型"><a href="#1-2-6-2-设置末端类型" class="headerlink" title="1.2.6.2 设置末端类型"></a>1.2.6.2 设置末端类型</h4><p>语法: <code>CanvasRenderingContext2D.lineCap = value</code></p>
<p>描述:</p>
<ol>
<li>设置线型末端的样式, 可取值为: ‘butt’( 默认 ), ‘round’, ‘square’.</li>
<li>‘butt’ 表示两端使用方形结束.</li>
<li>‘round’ 表示两端使用圆角结束.</li>
<li>‘square’ 表示突出的圆角结束.</li>
</ol>
<p><strong>小demo</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">...</div><div class="line">ctx.lineWidth = 10;</div><div class="line">ctx.moveTo( 100, 100 );</div><div class="line">ctx.lineTo( 300, 100 );</div><div class="line">ctx.stroke();</div><div class="line"></div><div class="line">ctx.beginPath();</div><div class="line">ctx.lineCap =  &apos;round&apos;;</div><div class="line">ctx.moveTo( 100, 130 );</div><div class="line">ctx.lineTo( 300, 130 );</div><div class="line">ctx.stroke();</div><div class="line"></div><div class="line">ctx.beginPath();</div><div class="line">ctx.lineCap =  &apos;square&apos;;</div><div class="line">ctx.moveTo( 100, 160 );</div><div class="line">ctx.lineTo( 300, 160 );</div><div class="line">ctx.stroke();</div></pre></td></tr></table></figure>
<img src="/2016/11/04/canvas/pic-3.png" alt="pic-3.png" title="">
<h3 id="1-2-6-3-设置相交线的拐点"><a href="#1-2-6-3-设置相交线的拐点" class="headerlink" title="1.2.6.3 设置相交线的拐点"></a>1.2.6.3 设置相交线的拐点</h3><p>语法: <code>CanvasRenderingContext2D.lineJoin = value</code></p>
<p>描述:</p>
<ol>
<li>设置两条直线的拐点描述方式. 可以取值 ‘round’, ‘bevel’, ‘miter’(默认)</li>
<li>‘round’ 使用圆角连接.</li>
<li>‘bevel’ 使用平切连接.</li>
<li>‘miter’ 使用直角转.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">...</div><div class="line">    ctx.lineWidth = 10;</div><div class="line">    ctx.lineJoin = &apos;round&apos;;</div><div class="line">    ctx.moveTo( 100, 100 );</div><div class="line">    ctx.lineTo( 200, 200 );</div><div class="line">    ctx.lineTo( 300, 100 );</div><div class="line">    ctx.stroke();</div><div class="line"></div><div class="line">    ctx.beginPath();</div><div class="line">    ctx.lineJoin = &apos;bevel&apos;;</div><div class="line">    ctx.moveTo( 100, 150 );</div><div class="line">    ctx.lineTo( 200, 250 );</div><div class="line">    ctx.lineTo( 300, 150 );</div><div class="line">    ctx.stroke();</div><div class="line"></div><div class="line">    ctx.beginPath();</div><div class="line">    ctx.lineJoin = &apos;miter&apos;;</div><div class="line">    ctx.moveTo( 100, 200 );</div><div class="line">    ctx.lineTo( 200, 300 );</div><div class="line">    ctx.lineTo( 300, 200 );</div><div class="line">    ctx.stroke();</div></pre></td></tr></table></figure>
<img src="/2016/11/04/canvas/pic-4.png" alt="pic-4.png" title="">
<h3 id="1-2-6-4-虚线"><a href="#1-2-6-4-虚线" class="headerlink" title="1.2.6.4 虚线"></a>1.2.6.4 虚线</h3><p>语法:</p>
<ol>
<li><code>CanvasRenderingContext2D.lineDashOffset = number</code></li>
<li><code>CanvasRenderingContext2D.getLineDash()</code></li>
<li><code>CanvasRenderingContext2D.setLineDash()</code></li>
</ol>
<p>描述:</p>
<ol>
<li>setLineDash 用于设置开始绘制虚线的偏移量. 数字的正负表示左右偏移.</li>
<li>getLineDash() 与 setLineDash() 方法使用数组描述实线与虚线的长度.</li>
</ol>
<p><strong>小demo</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">...</div><div class="line">ctx.moveTo( 100, 90 );</div><div class="line">ctx.lineTo( 100, 110 );</div><div class="line">ctx.moveTo( 300, 90 );</div><div class="line">ctx.lineTo( 300, 110 );</div><div class="line"></div><div class="line">ctx.moveTo( 100, 140 );</div><div class="line">ctx.lineTo( 100, 160 );</div><div class="line">ctx.moveTo( 300, 140 );</div><div class="line">ctx.lineTo( 300, 160 );</div><div class="line"></div><div class="line">ctx.moveTo( 100, 190 );</div><div class="line">ctx.lineTo( 100, 210 );</div><div class="line">ctx.moveTo( 300, 190 );</div><div class="line">ctx.lineTo( 300, 210 );</div><div class="line">ctx.stroke();</div><div class="line"></div><div class="line">ctx.beginPath();</div><div class="line">ctx.moveTo( 100, 100 );</div><div class="line">ctx.lineTo( 300, 100 );</div><div class="line">ctx.stroke();</div><div class="line"></div><div class="line">ctx.beginPath();</div><div class="line">ctx.setLineDash( [ 5, 5 ] );</div><div class="line">ctx.moveTo( 100, 150 );</div><div class="line">ctx.lineTo( 300, 150 );</div><div class="line">ctx.stroke();</div><div class="line"></div><div class="line">ctx.beginPath();</div><div class="line">ctx.lineDashOffset = -2;</div><div class="line">ctx.moveTo( 100, 200 );</div><div class="line">ctx.lineTo( 300, 200 );</div><div class="line">ctx.stroke();</div></pre></td></tr></table></figure>
<img src="/2016/11/04/canvas/pic-5.png" alt="pic-5.png" title="">
<h3 id="1-2-6-5-填充与描边样式"><a href="#1-2-6-5-填充与描边样式" class="headerlink" title="1.2.6.5 填充与描边样式"></a>1.2.6.5 填充与描边样式</h3><p>语法:</p>
<ol>
<li><code>CanvasRenderingContext2D.strokeStyle = value</code></li>
<li><code>CanvasRenderingContext2D.fillStyle = value</code></li>
</ol>
<p>描述:</p>
<ol>
<li>strokeStyle 可以设置描边颜色, 与 CSS 的语法一样</li>
<li>fillStyle 设置填充颜色, 与 CSS 语法一样</li>
<li>这两个属性还可以设置渐变对象.</li>
</ol>
<p><strong>小demo</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">for (var i=0;i&lt;6;i++)&#123;</div><div class="line">       for (var j=0;j&lt;6;j++)&#123;</div><div class="line">           ctx.strokeStyle = &apos;rgb(0,&apos; + Math.floor(255-42.5*i) + &apos;,&apos; +</div><div class="line">                           Math.floor(255-42.5*j) + &apos;)&apos;;</div><div class="line">           ctx.beginPath();</div><div class="line">           ctx.arc(12.5+j*25,12.5+i*25,10,0,Math.PI*2,true);</div><div class="line">           ctx.stroke();</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<img src="/2016/11/04/canvas/pic-6.png" alt="pic-6.png" title="">
<h2 id="1-3-实例练习"><a href="#1-3-实例练习" class="headerlink" title="1.3 实例练习"></a>1.3 实例练习</h2><h3 id="1-3-1-绘制坐标网络"><a href="#1-3-1-绘制坐标网络" class="headerlink" title="1.3.1 绘制坐标网络"></a>1.3.1 绘制坐标网络</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;&lt;/title&gt;</div><div class="line">    &lt;style&gt;</div><div class="line">        canvas &#123;</div><div class="line">            border: 1px solid red;</div><div class="line">        &#125;</div><div class="line">    &lt;/style&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;canvas id=&apos;cas&apos; width=&apos;600&apos; height=&apos;300&apos;&gt;&lt;/canvas&gt;</div><div class="line">&lt;script&gt;</div><div class="line">    var cas = document.getElementById(&apos;cas&apos;);</div><div class="line">    var content = cas.getContext(&apos;2d&apos;);</div><div class="line"></div><div class="line">    var smallWidth = 20;</div><div class="line">    for (var i = 0; i &lt; cas.height / smallWidth; i++) &#123;</div><div class="line">        content.moveTo(0, (i + 1) * smallWidth);</div><div class="line">        content.lineTo(cas.width, (i + 1) * smallWidth);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (var i = 0; i &lt; cas.width / smallWidth; i++) &#123;</div><div class="line">        content.moveTo((i + 1) * smallWidth, 0);</div><div class="line">        content.lineTo((i + 1) * smallWidth, cas.height);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    content.stroke();</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<img src="/2016/11/04/canvas/pic-7.png" alt="pic-7.png" title="">
<h3 id="1-3-2-绘制坐标网络"><a href="#1-3-2-绘制坐标网络" class="headerlink" title="1.3.2 绘制坐标网络"></a>1.3.2 绘制坐标网络</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">    &lt;title&gt;&lt;/title&gt;</div><div class="line">    &lt;style&gt;</div><div class="line">        canvas &#123;</div><div class="line">            border: 1px solid red;</div><div class="line">        &#125;</div><div class="line">    &lt;/style&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;canvas id=&apos;cas&apos; width=&apos;600&apos; height=&apos;300&apos;&gt;&lt;/canvas&gt;</div><div class="line">&lt;script&gt;</div><div class="line">    var cas = document.getElementById(&apos;cas&apos;);</div><div class="line">    var content = cas.getContext(&apos;2d&apos;);</div><div class="line">    //变量</div><div class="line">    var leftPadding = 30,</div><div class="line">            rightPadding = 30,</div><div class="line">            topPadding = 30,</div><div class="line">            bottomPadding = 30;</div><div class="line">    var arrowHeight = 20,</div><div class="line">            arrowWidth = 10,</div><div class="line">            arrowDeep = 2;</div><div class="line"></div><div class="line">    var x = leftPadding,</div><div class="line">            y = cas.height - bottomPadding;</div><div class="line">    //坐标轴</div><div class="line">    content.moveTo(x, topPadding);</div><div class="line">    content.lineTo(x, y);</div><div class="line">    content.lineTo(cas.width - rightPadding, y);</div><div class="line">    content.stroke();</div><div class="line">    //箭头</div><div class="line">    content.beginPath();</div><div class="line">    content.moveTo(leftPadding, topPadding);</div><div class="line">    content.lineTo(leftPadding - arrowWidth / 2, topPadding + arrowHeight);</div><div class="line">    content.lineTo(leftPadding, topPadding + arrowWidth / arrowDeep);</div><div class="line">    content.lineTo(leftPadding + arrowWidth / 2, topPadding + arrowHeight);</div><div class="line">    content.closePath();</div><div class="line"></div><div class="line">    content.moveTo(cas.width - rightPadding, y);</div><div class="line">    content.lineTo(cas.width - rightPadding - arrowHeight,y - arrowWidth/2);</div><div class="line">    content.lineTo(cas.width - rightPadding - arrowHeight/arrowDeep,y);</div><div class="line">    content.lineTo(cas.width - rightPadding - arrowHeight,y + arrowWidth/2);</div><div class="line">    content.closePath();</div><div class="line">    content.fill();</div><div class="line">    //随机数</div><div class="line">    function myRandom(min, max) &#123;</div><div class="line">        return (max - min) * Math.random() + min;</div><div class="line">    &#125;</div><div class="line">    //生成随机数</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<img src="/2016/11/04/canvas/pic-8.png" alt="pic-8.png" title="">
<h1 id="2-中级篇"><a href="#2-中级篇" class="headerlink" title="2. 中级篇"></a>2. 中级篇</h1><h2 id="2-1-绘制形状"><a href="#2-1-绘制形状" class="headerlink" title="2.1 绘制形状"></a>2.1 绘制形状</h2><p>绘制图形不仅仅是利用线条来实现绘图, 还可以有快捷的绘制图形的办法</p>
<ol>
<li>绘制矩形</li>
<li>绘制圆弧</li>
</ol>
<h3 id="2-1-1-绘制矩形"><a href="#2-1-1-绘制矩形" class="headerlink" title="2.1.1 绘制矩形"></a>2.1.1 绘制矩形</h3><p>绘制矩形的方法</p>
<ol>
<li><code>CanvasRenderingContext2D.strokeRect</code></li>
<li><code>CanvasRenderingContext2D.fillRect</code></li>
<li><code>CanvasRenderingContext2D.rect</code></li>
</ol>
<p>注意: <code>rect</code> 方法就是矩形路径, 还需要使用 <code>fill</code> 或 <code>stroke</code> 才可以看到效果. 因此一般使用 <code>strokeRect</code> 或 <code>fillRect</code> 直接可以看到结果.</p>
<p><strong>清除矩形区域</strong></p>
<p><code>CanvasRenderingContext2D.clearRect</code></p>
<h4 id="2-1-1-1-绘制矩形框"><a href="#2-1-1-1-绘制矩形框" class="headerlink" title="2.1.1.1 绘制矩形框"></a>2.1.1.1 绘制矩形框</h4><p>语法: <code>CanvasRenderingContext2D.strokeRect( x, y, width. height )</code></p>
<p>描述:</p>
<ol>
<li>用来绘制一个矩形. 比起直接使用 moveTo 和 lineTo 方法要简单许多.</li>
<li>该方法的前两个参数表示绘制矩形的左上角的坐标. 后两个参数表示这个矩形的宽高.</li>
<li>使用该方法不需要使用 moveTo 方法设置起始点, 也不需要调用 stroke 等绘画方法.</li>
<li>绘制的矩形支持 strokeStyle 设置颜色样式.</li>
</ol>
<p><strong>小demo</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">...</div><div class="line">   ctx.strokeStyle = &apos;red&apos;;</div><div class="line">   ctx.strokeRect( 100, 100, 200, 100 );</div></pre></td></tr></table></figure>
<img src="/2016/11/04/canvas/pic-9.png" alt="pic-9.png" title="">
<h4 id="2-1-1-2-绘制填充矩形"><a href="#2-1-1-2-绘制填充矩形" class="headerlink" title="2.1.1.2 绘制填充矩形"></a>2.1.1.2 绘制填充矩形</h4><p>语法: <code>CanvasRenderingContext2D.fillRect( x, y, width. height )</code></p>
<p>描述:</p>
<ol>
<li>用来绘制一个矩形. 比起直接使用 <code>moveTo</code> 和 <code>lineTo</code> 方法要简单许多.</li>
<li>该方法的前两个参数表示绘制矩形的左上角的坐标. 后两个参数表示这个矩形的宽高.</li>
<li>使用该方法不需要使用 <code>moveTo</code> 方法设置起始点, 也不需要调用 <code>stroke</code> 等绘画方法.</li>
<li>绘制的矩形支持 <code>fillStyle</code> 设置颜色样式.</li>
</ol>
<p><strong>小demo</strong></p>
<img src="/2016/11/04/canvas/pic-10.png" alt="pic-10.png" title="">
<h4 id="2-1-1-3-清除矩形区域"><a href="#2-1-1-3-清除矩形区域" class="headerlink" title="2.1.1.3 清除矩形区域"></a>2.1.1.3 清除矩形区域</h4><p>语法: <code>CanvasRenderingContext2D.clearRect( x, y, width, height )</code></p>
<p>描述:</p>
<ol>
<li>用于清除画布中的矩形区域的内容.</li>
<li>参数 x, y 表示矩形区域左上角的坐标, width 与 height 表示矩形区域的宽高.</li>
</ol>
<h3 id="2-1-2-绘制圆弧"><a href="#2-1-2-绘制圆弧" class="headerlink" title="2.1.2 绘制圆弧"></a>2.1.2 绘制圆弧</h3><p><strong>绘制圆弧的方法</strong></p>
<p>语法: <code>CanvasRenderingContext2D.arc( x, y, radius. startAngle. endAngle, anticlockwise )</code></p>
<p>描述:</p>
<ol>
<li>该方法用于绘制一段弧, 配合开始点的位置 与 stroke 方法或 fill 方法可以绘制扇形.</li>
<li>方法中的前两个参数 x, y 表示绘制圆弧的圆心坐标.</li>
<li>参数 radius 表示圆弧半径, 单位为弧度.</li>
<li>参数 startAngle 与 endAngle 表示开始到结束的角度. 角度以水平向右为 0 弧度, 顺时针为正方向.</li>
<li>参数 anticlockwise 表示是否采用默认的正向角度, 如果传入 true 表示逆指针为正. 该参数可选.</li>
</ol>
<p><strong>小demo</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// 在 200, 200 的地方绘制一段半径为 100 的圆弧, 圆心角为 - PI / 2 到 PI / 4</div><div class="line">...</div><div class="line">ctx.arc( 200, 200, 100, -Math.PI/2, Math.PI/4 );</div><div class="line">ctx.stroke();</div><div class="line"></div><div class="line">// 为了方便看清楚结构, 绘制坐标轴</div><div class="line">ctx.beginPath();</div><div class="line">ctx.strokeStyle = &apos;red&apos;;</div><div class="line">ctx.moveTo( 50, 200 );</div><div class="line">ctx.lineTo( 350, 200 );</div><div class="line"></div><div class="line">ctx.moveTo( 200, 50 );</div><div class="line">ctx.lineTo( 200, 350 );</div><div class="line"></div><div class="line">ctx.moveTo( 200, 200 );</div><div class="line">ctx.lineTo( 300, 300 );</div><div class="line"></div><div class="line">ctx.stroke();</div></pre></td></tr></table></figure>
<img src="/2016/11/04/canvas/pic-11.png" alt="pic-11.png" title="">
<p><strong>注意</strong></p>
<ol>
<li>使用 arc 绘图的时候, 如果没有设置 moveTo 那么会从开始的绘弧的地方作为起始点. 如果设置了 moveTo, 那么会连线该点与圆弧的起点.</li>
<li>如果使用 stroke 方法, 那么会从开始连线到圆弧的起始位置. 如果是 fill 方法, 会自动闭合路径填充.</li>
</ol>
<h3 id="2-1-3-绘制扇形"><a href="#2-1-3-绘制扇形" class="headerlink" title="2.1.3 绘制扇形"></a>2.1.3 绘制扇形</h3><p>绘制扇形的重点是需要设置起始位置为圆心点, 然后闭合路径即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">...</div><div class="line"> ctx.strokeStyle = &apos;red&apos;;</div><div class="line"> ctx.fillStyle = &apos;pink&apos;;</div><div class="line"></div><div class="line"> ctx.moveTo( 100, 200 );</div><div class="line"> ctx.arc( 100, 200, 100, -Math.PI/3, Math.PI/3 );</div><div class="line"> ctx.closePath();</div><div class="line"> ctx.stroke();</div><div class="line"></div><div class="line"> ctx.beginPath();</div><div class="line"> ctx.moveTo( 300, 200 );</div><div class="line"> ctx.arc( 300, 200, 100, -Math.PI/3, Math.PI/3 );</div><div class="line"> ctx.closePath();</div><div class="line"> ctx.fill();</div></pre></td></tr></table></figure>
<img src="/2016/11/04/canvas/pic-12.png" alt="pic-12.png" title="">
<h3 id="2-1-4-绘制饼形图"><a href="#2-1-4-绘制饼形图" class="headerlink" title="2.1.4 绘制饼形图"></a>2.1.4 绘制饼形图</h3><p>绘制饼形图最大的特点是角度是叠加的. 开始从 <code>-Math.PI/2</code> 开始绘制, 达到执行角 <code>x</code> 后, 下一个区域从 <code>x</code> 开始绘制, 然后有到一个角 <code>y</code> 停下来. 如此反复到 <code>Math.PI * 3 / 2</code> 结束.</p>
<p>本节看两个案例, 一个固定等分, 一个由数据源来定义角度.</p>
<p><strong>小demo</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var x = 200, y = 200,</div><div class="line">       r = 100,</div><div class="line">       step = Math.PI * 2 / 3,     // 120 度一个区域</div><div class="line">       start = -Math.PI / 2,       // 起始角度</div><div class="line">       colors = [ &apos;red&apos;, &apos;green&apos;, &apos;blue&apos; ];</div><div class="line"></div><div class="line">   for ( var i = 0; i &lt; 3; i++ ) &#123;</div><div class="line">       ctx.beginPath();</div><div class="line">       ctx.moveTo( x, y );</div><div class="line">       ctx.fillStyle = colors[ i ];</div><div class="line">       ctx.arc( x, y, r, start, start+=step );</div><div class="line">       ctx.fill();</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<img src="/2016/11/04/canvas/pic-13.png" alt="pic-13.png" title="">
<h2 id="2-2-绘制文本"><a href="#2-2-绘制文本" class="headerlink" title="2.2 绘制文本"></a>2.2 绘制文本</h2><p>绘制文本的方法</p>
<ol>
<li><code>CanvasRenderingContext2D.fillText()</code></li>
<li><code>CanvasRenderingContext2D.strokeText()</code></li>
<li><code>CanvasRenderingContext2D.measureText()</code></li>
</ol>
<h3 id="2-2-1-绘制文字"><a href="#2-2-1-绘制文字" class="headerlink" title="2.2.1 绘制文字"></a>2.2.1 绘制文字</h3><p>语法:</p>
<ol>
<li><code>CanvasRenderingContext2D.strokeText( text, x, y[, maxWidth] )</code></li>
<li><code>CanvasRenderingContext2D.fillText( text, x, y[, maxWidth] )</code></li>
</ol>
<p>描述:</p>
<ol>
<li>这两个方法的功能都是在给定的 x, y 坐标下绘制文本内容.</li>
<li>stroke 绘制描边文字, 文字内空心. fill 绘制填充文字, 即实心文字.</li>
<li>最后一个参数可选, 用于限制文字的总宽. 特殊条件下, 系统会自动调整文字宽度与大小以适应该参数限制.</li>
</ol>
<p><strong>小demo</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">...</div><div class="line">    ctx.strokeRect( 100, 100, 200, 50 );</div><div class="line">    ctx.strokeText( &apos;Hello JK&apos;, 100, 100 );</div><div class="line"></div><div class="line">    ctx.strokeRect( 100, 200, 200, 50 );</div><div class="line">    ctx.fillText( &apos;Hello JK&apos;, 100, 200 );</div></pre></td></tr></table></figure>
<p>% asset_img pic-14.png %}</p>
<p>注意: 第一个文字由于中间空心, 所以文字相当于双线显示. 就显得较粗.</p>
<p>根据绘制的矩形块可以发现文字几乎使用该点作为文字基线参考.</p>
<h3 id="2-2-2-计算文本尺寸"><a href="#2-2-2-计算文本尺寸" class="headerlink" title="2.2.2 计算文本尺寸"></a>2.2.2 计算文本尺寸</h3><p>语法: <code>CanvasRenderingContext2D.measureText()</code></p>
<p>描述:</p>
<ol>
<li>该方法返回一个文本尺寸对象, TextMetrics 对象.</li>
<li>TextMetrics 对象属性很多, 常用的 width 属性可以获取文字的宽度.</li>
</ol>
<h3 id="2-2-3-设置文字属性"><a href="#2-2-3-设置文字属性" class="headerlink" title="2.2.3 设置文字属性"></a>2.2.3 设置文字属性</h3><h4 id="2-2-3-1-设置文字字体"><a href="#2-2-3-1-设置文字字体" class="headerlink" title="2.2.3.1 设置文字字体"></a>2.2.3.1 设置文字字体</h4><p>语法: <code>CanvasRenderingContext2D.font = value</code></p>
<p>描述:</p>
<ol>
<li>该属性用于设置绘制字体的各种信息, 与 CSS 语法一致, 设置字体形状, 样式, 字号粗细等.</li>
<li>其顺序可以是: style | variant | weight | size/line-height | family.</li>
<li>默认值为 10px sans-serif</li>
</ol>
<p>修改字号后查看strokeText 与 fillText 的区别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">...</div><div class="line">  ctx.font = &apos;50px 黑体&apos;;</div><div class="line">  ctx.strokeRect( 100, 100, 200, 50 );</div><div class="line">  ctx.strokeText( &apos;Hello JK&apos;, 100, 100 );</div><div class="line"></div><div class="line">  ctx.strokeRect( 100, 200, 200, 50 );</div><div class="line">  ctx.fillText( &apos;Hello JK&apos;, 100, 200 );</div></pre></td></tr></table></figure>
<img src="/2016/11/04/canvas/pic-15.png" alt="pic-15.png" title="">
<h4 id="2-2-3-2-设置字体水平对齐方式"><a href="#2-2-3-2-设置字体水平对齐方式" class="headerlink" title="2.2.3.2 设置字体水平对齐方式"></a>2.2.3.2 设置字体水平对齐方式</h4><p>语法: <code>anvasRenderingContext2D.textAlign = value</code></p>
<p>描述:</p>
<ol>
<li>该属性用于设置文字的水平对齐方式. 设置文字居中, 靠左右对齐等.</li>
<li>该属性可以设置的值有: start( 默认 ), end, left, right, center.</li>
</ol>
<p>start 表示根据参考基准点的垂直直线左靠对齐</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">...</div><div class="line">  ctx.moveTo( 150, 100 );</div><div class="line">  ctx.lineTo( 150, 200 );</div><div class="line">  ctx.moveTo( 100, 150 );</div><div class="line">  ctx.lineTo( 200, 150 );</div><div class="line">  ctx.strokeStyle = &apos;red&apos;;</div><div class="line">  ctx.stroke();</div><div class="line"></div><div class="line">  ctx.font = &apos;30px 黑体&apos;;</div><div class="line">  ctx.textAlign = &apos;start&apos;; // 默认</div><div class="line">  ctx.fillText( &apos;测试文字&apos;, 150, 150 );</div></pre></td></tr></table></figure>
<img src="/2016/11/04/canvas/pic-16.png" alt="pic-16.png" title="">
<p>end 表示根据参考基准点的垂直直线右靠对齐</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">...</div><div class="line">   ctx.font = &apos;30px 黑体&apos;;</div><div class="line">   ctx.textAlign = &apos;end&apos;;</div><div class="line">   ctx.fillText( &apos;测试文字&apos;, 150, 150 );</div></pre></td></tr></table></figure>
<img src="/2016/11/04/canvas/pic-17.png" alt="pic-17.png" title="">
<h4 id="2-2-3-3-设置字体垂直对齐方式"><a href="#2-2-3-3-设置字体垂直对齐方式" class="headerlink" title="2.2.3.3 设置字体垂直对齐方式"></a>2.2.3.3 设置字体垂直对齐方式</h4><p>语法:  <code>CanvasRenderingContext2D.textBaseline = value</code></p>
<p>描述:</p>
<ol>
<li>该方法设置文字在垂直方向上的对齐方式.</li>
<li>该属性可以取值: top, middle, bottom, hanging, alphabetic, ideographic</li>
<li>基于参考点的直线, 其中 top, middle, buttom 分别表示靠上, 居中, 靠下对齐.</li>
<li>alphabetic 表示字母基线, 类似于英文字母的对齐方式. 例如 a, g, f 等字母.</li>
<li>ideographic 表意对齐. 使用字母对齐中超出的字母为参考. 即比字母基线略靠下.</li>
<li>所有的对齐方式是根据文字特点相关的. 对于中文主要使用的还是 top, bottom 和 middle.top, middle, bottom 使用的较多</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">...</div><div class="line">   // ------------------</div><div class="line">   ctx.moveTo( 100, 80 );</div><div class="line">   ctx.lineTo( 500, 80 );</div><div class="line">   ctx.strokeStyle = &apos;red&apos;;</div><div class="line">   ctx.stroke();</div><div class="line"></div><div class="line">   ctx.font = &apos;30px 黑体&apos;;</div><div class="line"></div><div class="line">   ctx.textBaseline = &apos;top&apos;;</div><div class="line">   ctx.fillText( &apos;abfghijklpqrty&apos;, 150, 80 );</div><div class="line"></div><div class="line">   // ------------------</div><div class="line">   ctx.translate( 0, 100 );</div><div class="line">   ctx.moveTo( 100, 80 );</div><div class="line">   ctx.lineTo( 500, 80 );</div><div class="line">   ctx.strokeStyle = &apos;red&apos;;</div><div class="line">   ctx.stroke();</div><div class="line"></div><div class="line">   ctx.font = &apos;30px 黑体&apos;;</div><div class="line"></div><div class="line">   ctx.textBaseline = &apos;bottom&apos;;</div><div class="line">   ctx.fillText( &apos;abfghijklpqrty&apos;, 150, 80 );</div><div class="line"></div><div class="line">   // ------------------</div><div class="line">   ctx.translate( 0, 100 );</div><div class="line">   ctx.moveTo( 100, 80 );</div><div class="line">   ctx.lineTo( 500, 80 );</div><div class="line">   ctx.strokeStyle = &apos;red&apos;;</div><div class="line">   ctx.stroke();</div><div class="line"></div><div class="line">   ctx.font = &apos;30px 黑体&apos;;</div><div class="line"></div><div class="line">   ctx.textBaseline = &apos;middle&apos;;</div><div class="line">   ctx.fillText( &apos;abfghijklpqrty&apos;, 150, 80 );</div></pre></td></tr></table></figure>
<img src="/2016/11/04/canvas/pic-18.png" alt="pic-18.png" title="">
<h2 id="2-3-绘制图片"><a href="#2-3-绘制图片" class="headerlink" title="2.3 绘制图片"></a>2.3 绘制图片</h2><p> 绘制图像虽然只有一个  <code>drawImage</code> 函数, 但是该函数有多重参数形式.</p>
<ol>
<li><code>CanvasRenderingContext2D.drawImage( img, dx, dy ).</code></li>
<li><code>CanvasRenderingContext2D.drawImage( img, dx, dy, dWidth, dHeight ).</code></li>
<li><p><code>CanvasRenderingContext2D.drawImage( img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight ).</code></p>
<h3 id="2-3-1-绘制简单图像"><a href="#2-3-1-绘制简单图像" class="headerlink" title="2.3.1 绘制简单图像"></a>2.3.1 绘制简单图像</h3><p>语法: <code>CanvasRenderingContext2D.drawImage( img, dx, dy )</code></p>
<p>描述:</p>
</li>
<li><p>使用三个参数, 允许在画布上的 任意位置 绘制图片.</p>
</li>
<li>参数 img 是指图片对象. 可以是 img 标签, 或者是 video 标签, 已经另一个 canvas 等.</li>
<li><p>需要注意的是如果直接添加 img 对象是不可以的, 需要等待其加载.</p>
<p><strong>准备一张网络图片, 绘制, 便于查看其加载过程.</strong><br><strong>因为加载图片需要时间, 因此将绘制的方法放在 onload 事件中.</strong></p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// 随便从百度中搜索图片, 记录一个链接地址</div><div class="line">   var url = &apos;http://imgsrc.baidu.com/forum/pic/item/94cad1c8a786c917667cc578c93d70cf3bc75777.jpg&apos;;</div><div class="line">   // 创建 img 对象</div><div class="line">   var img = new Image(); // 就是 img 标签</div><div class="line">   // 设置 src 属性为 图片</div><div class="line">   img.src = url;</div><div class="line"></div><div class="line">   // 绘图</div><div class="line">   img.onload = function () &#123;</div><div class="line">       ctx.drawImage(img,100,200,150,100,0,0,400,200);</div><div class="line">   &#125;;</div></pre></td></tr></table></figure>
<img src="/2016/11/04/canvas/pic-19.png" alt="pic-19.png" title="">
<h3 id="2-3-2-在指定区域内绘制图像"><a href="#2-3-2-在指定区域内绘制图像" class="headerlink" title="2.3.2 在指定区域内绘制图像"></a>2.3.2 在指定区域内绘制图像</h3><p>当图片比较大的时候, 如果使用这样的方式绘图, 那么图片可能会完全覆盖画布</p>

<p>语法: <code>CanvasRenderingContext2D.drawImage( img, dx, dy, dWidth, dHeight )</code></p>
<p>描述:</p>
<ol>
<li>参数 dWidth, dHeight 表示绘制的矩形区域. 绘制的 dx, dy 坐标决定了开始.</li>
<li>该方法绘制的图像会在指定范围内被压缩显示.</li>
</ol>
<p>将上面的图绘制在 <code>100 * 100</code> 的范围内.</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">...</div><div class="line">   ctx.drawImage( img, 100, 100, 100, 100 );</div></pre></td></tr></table></figure>
<img src="/2016/11/04/canvas/pic-21.png" alt="pic-21.png" title="">
<h3 id="2-3-3-绘制任意图像"><a href="#2-3-3-绘制任意图像" class="headerlink" title="2.3.3. 绘制任意图像"></a>2.3.3. 绘制任意图像</h3><p>类似于 CSS 中处理按钮等小图标的技巧, 将很多的效果图集中在一张 png 格式的背景透明的图片中, 这样可以提高效率也便于维护. 那么 drawImage 同样支持该方式绘图. 在画布中的指定位子与指定区域内, 绘制图片中的某个矩形区.</p>
<p>语法: <code>CanvasRenderingContext2D.drawImage( img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight )</code></p>
<p>描述: 这里的带有 s 前缀的参数就是指图源的矩形区域.</p>
<p>例如将图片的 ( 100, 100, 300, 200 ) 处的内容绘制到页面的 <code>( 100, 100, 300, 200 )</code> 的位置.</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&apos;&apos;&apos;</div><div class="line">ctx.drawImage( img, 100, 100, 300, 200,  100, 100, 300, 200 );</div></pre></td></tr></table></figure>
<img src="/2016/11/04/canvas/pic-22.png" alt="pic-22.png" title="">
<h1 id="3-高级篇"><a href="#3-高级篇" class="headerlink" title="3. 高级篇"></a>3. 高级篇</h1><h2 id="3-1-变换"><a href="#3-1-变换" class="headerlink" title="3.1 变换"></a>3.1 变换</h2><h3 id="3-1-1-平移变换"><a href="#3-1-1-平移变换" class="headerlink" title="3.1.1 平移变换"></a>3.1.1 平移变换</h3><p> 平移变换就是将原有坐标轴进行平行移动, 那么坐标轴移动后就可以使用新坐标来绘制图形了.</p>
<p> 语法: <code>CanvasRenderingContext2D.translate( x, y )</code></p>
<p> 描述:</p>
<ol>
<li>该方法将坐标进行平移.</li>
<li>x 表示水平移动, 正数向右, 负数向左.</li>
<li>y 表示垂直移动, 正数向下, 负数向上.</li>
<li><p>变换可以重复调用, 变换是可以累加的.</p>
<p><strong>使用该变换, 常常用于绘制不同位置, 但是形状重复的图形.</strong></p>
<p><strong>注意: 变换也会被 “继承”, 开启新路径后依旧保留原先变换.</strong></p>
<h3 id="3-1-2-旋转变换"><a href="#3-1-2-旋转变换" class="headerlink" title="3.1.2 旋转变换"></a>3.1.2 旋转变换</h3><p>语法: <code>CanvasRenderingContext2D.rotate( radian )</code></p>
<p>描述:</p>
</li>
</ol>
<ol>
<li>该方法实现水平与垂直的缩放.</li>
<li>参数 x 控制水平缩放倍率. 传参 1 表示不作缩放, 传入大于 1 的数字表示扩大.</li>
<li>参数 y 控制垂直缩放倍率. 传参 1 表示不作缩放, 传入大于 1 的数字表示扩大.</li>
</ol>
<p><strong>该变换常常用于放大与缩小, 以及反转的效果.</strong></p>
<h2 id="3-2-环境"><a href="#3-2-环境" class="headerlink" title="3.2 环境"></a>3.2 环境</h2><p>前面提到 Canvas 是含有状态的, 也就是说需要修改颜色, 直线样式, 绘图方式等效果时需要开启一个新的状态. 但是有时在绘制过程中需要修改状态, 同时绘制完当前状态后又需要回到之前的状态中继续绘制另外的形状. 那么只有再将修改过的样式载更改回来. 如果在该状态中修改的属性较多, 那么每次在回到之前状态时就有很多的代码.</p>
<p>Canvas 中引入了状态的保持机制. 使用 <code>CanvasRenderingContext2D.save()</code> 方法可以保存当前状态. 如果需要恢复到已经保存的状态, 只需要调用 <code>CanvasRenderingContext2D.restore()</code> 方法即可.</p>
<p>状态保持的机制是基于状态栈实现的. 也就是说 save 一次就存储一个状态. restore 一次就将刚刚存入的恢复. 如果 save 两次, 就需要 restore 两次, 才可以恢复到最先的状态.</p>
<p>一般在封装绘图的时候都会采用开始绘制之前, save 一次, 然后 开启一个新路径, 然后绘制结束后 restore, 然后再开启一个新路径. 这样保持当前状态不会对其他绘图代码构成影响.</p>
<h2 id="3-3-画布保存"><a href="#3-3-画布保存" class="headerlink" title="3.3 画布保存"></a>3.3 画布保存</h2><p>画布在绘制后实际上就是一张图片, 可以直接右键另存为. 同时也支持使用 js 代码将其保存为 base64 编码的字符串.</p>
<p>语法: <code>anvas.ToDataURL( type, encoderOptions )</code></p>
<p>描述:</p>
<ol>
<li>该方法可以将画布转换成 base64 格式的数据</li>
<li>type 表示输出类型. 例如: image/png 或 image/jpeg 等</li>
<li><p>encoderOptions 表示图片输出质量, 其取值在 0 到 1 之间. 如果是 1, 表示无损压缩, 必须使用 image/jpeg 或 image/webp 才起作用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">...</div><div class="line">   &lt;img id=&quot;img&quot;/&gt;</div><div class="line">   ...</div><div class="line">   var img = document.getElementById( &apos;img&apos; );</div><div class="line"></div><div class="line">   var cas = document.createElement( &apos;canvas&apos; );</div><div class="line">   cas.width = 100, cas.height = 100;</div><div class="line">   var ctx = cas.getContext( &apos;2d&apos; );</div><div class="line">   ctx.fillStyle = &apos;pink&apos;;</div><div class="line">   ctx.fillRect( 0, 0, 100, 100 );</div><div class="line"></div><div class="line">   var data = cas.toDataURL( &apos;image/png&apos;, 1 );</div><div class="line"></div><div class="line">   img.src = data;</div></pre></td></tr></table></figure>
<h2 id="3-4-渐变和图案"><a href="#3-4-渐变和图案" class="headerlink" title="3.4 渐变和图案"></a>3.4 渐变和图案</h2><p>绘制图像有两个主要方法, 一个是描边, 一个是填充. 前面介绍过要设置其样式, 可以使用 strokeStyle 和 fillStyle 属性, 只需要给它们提供颜色就可以了. 但是不仅仅是颜色, 它还支持渐变和重复.</p>
<p>语法:</p>
<p><code>CanvasRenderingContext2D.createLinearGradient()</code><br><code>CanvasRenderingContext2D.createRadialGradient()</code><br><code>CanvasRenderingContext2D.createPattern()</code></p>
<h3 id="3-4-1-线性渐变"><a href="#3-4-1-线性渐变" class="headerlink" title="3.4.1 线性渐变"></a>3.4.1 线性渐变</h3><p>语法: <code>CanvasRenderingContext2D.createLinearGradient( x0, y0, x1, y1 )</code></p>
<p>描述:</p>
<ol>
<li>该方法返回一个 CanvasGradient 对象. 用于描述渐变的方式.</li>
<li>该方法有两个参数, 用于表示线型渐变的方向与位置.</li>
<li>使用的时候, 首先创建一个 CanvasGradient 对象, 然后利用 addColorStop 方法添加颜色区间.<ol>
<li>方法语法: CanvasGradient.addColorStop( rate, color ).</li>
<li>该方法用于设置在某个比例位置的颜色是什么. rate 的取值是 0 到 1 之间.</li>
<li>可以添加多个渐变点.</li>
<li>然后将该对象赋值给 *Style 属性即可.</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">..</div><div class="line">    var canvasGradient = ctx.createLinearGradient( 0, 25, 200, 25 );</div><div class="line">    canvasGradient.addColorStop( 0, &apos;blue&apos; );</div><div class="line">    canvasGradient.addColorStop( 1, &apos;red&apos; );</div><div class="line">    ctx.fillStyle = canvasGradient;</div><div class="line"></div><div class="line">    ctx.fillRect( 0, 100, 200, 50 );</div></pre></td></tr></table></figure>
<img src="/2016/11/04/canvas/pic-23.png" alt="pic-23.png" title="">
<p><strong>注意: 渐变点的坐标是基于坐标轴来计算的.</strong></p>
<h3 id="3-4-2-放射渐变"><a href="#3-4-2-放射渐变" class="headerlink" title="3.4.2 放射渐变"></a>3.4.2 放射渐变</h3><p>语法: <code>CanvasRenderingContext2D.createRadialGradient( x0, y0, r0, x1, y1, r1 )</code></p>
<p>描述:</p>
<ol>
<li>该方法实现放射渐变, 渐变的是在两个圆之间. 一般会使用两个内含关系的圆.</li>
<li>前三个参数分别表示其中一个圆的圆心的坐标, 以及半径.</li>
<li>后三个参数分别表示另一个圆的圆心的坐标, 以及半径.</li>
<li>绘制渐变效果用法与线性渐变一样.</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var x = cas.width / 2, y = cas.height / 2, r = 100;</div><div class="line">var g = ctx.createRadialGradient( x + r * 2 / 3, y - r * 2 / 3, 0, x + r / 3, y - r / 3, r * 4 / 3 );</div><div class="line">g.addColorStop( 0, &apos;#fff&apos; );</div><div class="line">g.addColorStop( 1, &apos;#f00&apos; );</div><div class="line">ctx.fillStyle = g;</div><div class="line">ctx.arc( x, y, r, 0, 2 * Math.PI );</div><div class="line">ctx.fill();</div></pre></td></tr></table></figure>
<img src="/2016/11/04/canvas/pic-24.png" alt="pic-24.png" title="">
<h2 id="3-5-阴影"><a href="#3-5-阴影" class="headerlink" title="3.5 阴影"></a>3.5 阴影</h2><p>在 Canvas 中还可以给绘制的内容设置阴影. 但是一般不这么用, 因为性能不高.</p>
<p><strong>相关属性:</strong></p>
<ol>
<li><code>CanvasRenderingContext2D.shadowBlur 属性表示模糊程度.</code></li>
<li><code>CanvasRenderingContext2D.shadowColor 属性表示模糊颜色.</code></li>
<li><code>CanvasRenderingContext2D.shadowOffsetX 属性表示模糊位置 x 坐标偏移.</code></li>
<li><code>CanvasRenderingContext2D.shadowOffsetY 属性表示模糊位置 y 坐标偏移.</code></li>
</ol>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/11/04/canvas/" class="archive-article-date">
  	<time datetime="2016-11-04T11:45:33.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-11-04</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/04/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/11/04/hello-world/" class="archive-article-date">
  	<time datetime="2016-11-04T11:38:54.149Z" itemprop="datePublished"><i class="icon-clock"></i>2016-11-04</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>










  
  


      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Sun Hao Nan
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: true,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				
    			</div>
    	</section>
    

    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">Sun，&lt;br&gt;毕业于山东理工大学&lt;br&gt;&lt;br&gt;奋斗在前端一线&lt;br/&gt;目前是一枚前端&lt;br/&gt;&lt;br/&gt;热爱生活&lt;br&gt;热爱自然</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>